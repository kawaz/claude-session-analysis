#!/usr/bin/env bun
// @bun

// src/resolve-session.ts
async function resolveSession(input) {
  if (await Bun.file(input).exists()) {
    return input;
  }
  if (!/^[a-f0-9-]+$/.test(input)) {
    throw new Error(`Invalid session ID: ${input}`);
  }
  const configDir = process.env.CLAUDE_CONFIG_DIR;
  const defaultDir = `${process.env.HOME}/.claude`;
  const searchDirs = [];
  if (configDir) {
    searchDirs.push(configDir);
    if (configDir !== defaultDir) {
      searchDirs.push(defaultDir);
    }
  } else {
    searchDirs.push(defaultDir);
  }
  const glob = new Bun.Glob(`projects/*/${input}*.jsonl`);
  for (const dir of searchDirs) {
    for (const match of glob.scanSync(dir)) {
      return `${dir}/${match}`;
    }
  }
  const searched = searchDirs.map((d) => `${d}/projects/*/`).join(", ");
  throw new Error(`Session not found: ${input}
  Searched in: ${searched}
  Hint: Use a full session ID or provide a direct file path`);
}

// src/file-diff/resolve.ts
import { statSync } from "fs";
function getClaudeConfigDirs(claudeConfigDir, home) {
  const defaultDir = `${home}/.claude`;
  if (!claudeConfigDir) {
    return [defaultDir];
  }
  if (claudeConfigDir === defaultDir) {
    return [defaultDir];
  }
  return [claudeConfigDir, defaultDir];
}
async function findSessionDir(sessionId, configDirs) {
  const glob = new Bun.Glob(`${sessionId}*`);
  for (const dir of configDirs) {
    const fileHistoryDir = `${dir}/file-history`;
    try {
      for (const match of glob.scanSync({ cwd: fileHistoryDir, onlyFiles: false })) {
        const fullPath = `${fileHistoryDir}/${match}`;
        try {
          if (statSync(fullPath).isDirectory()) {
            return fullPath;
          }
        } catch {
          continue;
        }
      }
    } catch {
      continue;
    }
  }
  return null;
}
async function findBackupFile(sessionDir, hashPrefix, version) {
  const glob = new Bun.Glob(`${hashPrefix}*@v${version}`);
  for (const match of glob.scanSync(sessionDir)) {
    return `${sessionDir}/${match}`;
  }
  return null;
}
function findOriginalPath(jsonlContent, fullHash) {
  const lines = jsonlContent.split(`
`).filter((line) => line.trim());
  for (const line of lines) {
    let entry;
    try {
      entry = JSON.parse(line);
    } catch {
      continue;
    }
    if (entry.type !== "file-history-snapshot")
      continue;
    const snapshot = entry.snapshot;
    const backups = snapshot?.trackedFileBackups;
    if (!backups)
      continue;
    for (const [filePath, backup] of Object.entries(backups)) {
      const backupFileName = backup.backupFileName ?? "";
      if (backupFileName.startsWith(`${fullHash}@`)) {
        return filePath;
      }
    }
  }
  return null;
}

// src/file-diff/index.ts
async function main() {
  const args = process.argv.slice(2);
  if (args[0] === "--help") {
    const prog = process.env._PROG || "file-diff";
    console.log(`Usage: ${prog} <session_id_prefix> <backup_hash_prefix> <v1> [v2]`);
    console.log("  v2 omitted: diff backup v1 vs current file");
    return;
  }
  const [sessionId, hashPrefix, v1Str, v2Str] = args;
  if (!sessionId || !hashPrefix || !v1Str) {
    const prog = process.env._PROG || "file-diff";
    console.error(`Usage: ${prog} <session_id_prefix> <backup_hash_prefix> <v1> [v2]`);
    console.error("  v2 omitted: diff backup v1 vs current file");
    process.exit(1);
  }
  if (!/^[a-f0-9-]+$/.test(sessionId)) {
    console.error(`Invalid session ID: ${sessionId}`);
    process.exit(1);
  }
  if (!/^[a-f0-9]+$/.test(hashPrefix)) {
    console.error(`Invalid hash prefix: ${hashPrefix}`);
    process.exit(1);
  }
  const v1 = Number(v1Str);
  if (!/^[0-9]+$/.test(v1Str)) {
    console.error(`Invalid version number v1: ${v1Str}`);
    process.exit(1);
  }
  if (v2Str !== undefined && !/^[0-9]+$/.test(v2Str)) {
    console.error(`Invalid version number v2: ${v2Str}`);
    process.exit(1);
  }
  const v2 = v2Str !== undefined ? Number(v2Str) : undefined;
  const configDirs = getClaudeConfigDirs(process.env.CLAUDE_CONFIG_DIR, process.env.HOME);
  const sessionDir = await findSessionDir(sessionId, configDirs);
  if (!sessionDir) {
    console.error(`Session not found: ${sessionId}`);
    console.error("Hint: Use 'claude-session-analysis sessions' to list available sessions");
    process.exit(1);
  }
  const file1 = await findBackupFile(sessionDir, hashPrefix, v1);
  if (!file1) {
    console.error(`File not found: ${hashPrefix}*@v${v1}`);
    console.error("Hint: Use 'claude-session-analysis timeline <session_id> --types F' to list file operations");
    process.exit(1);
  }
  let file2;
  if (v2 !== undefined) {
    const found = await findBackupFile(sessionDir, hashPrefix, v2);
    if (!found) {
      console.error(`File not found: ${hashPrefix}*@v${v2}`);
      console.error("Hint: Use 'claude-session-analysis timeline <session_id> --types F' to list file operations");
      process.exit(1);
    }
    file2 = found;
  } else {
    const backupFilename = file1.split("/").pop();
    const fullHash = backupFilename.replace(/@v\d+$/, "");
    const sessionFile = await resolveSession(sessionId);
    const jsonlContent = await Bun.file(sessionFile).text();
    const originalPath = findOriginalPath(jsonlContent, fullHash);
    if (!originalPath) {
      console.error(`Could not find original file path for hash: ${fullHash}`);
      process.exit(1);
    }
    if (!await Bun.file(originalPath).exists()) {
      console.error(`Original file no longer exists: ${originalPath}`);
      process.exit(1);
    }
    file2 = originalPath;
  }
  console.log(`# diff ${file1} ${file2}`);
  const proc = Bun.spawn(["diff", file1, file2], {
    stdout: "inherit",
    stderr: "inherit"
  });
  const exitCode = await proc.exited;
  if (exitCode >= 2) {
    process.exit(exitCode);
  }
}
main().catch((err) => {
  console.error(err.message);
  process.exit(1);
});
