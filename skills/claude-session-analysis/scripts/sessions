#!/usr/bin/env bun
// @bun

// src/sessions/search.ts
import { stat } from "fs/promises";
async function searchSessions(opts) {
  const { configDirs, mmin, keyword } = opts;
  const projectDirs = [];
  for (const dir of configDirs) {
    const pDir = `${dir}/projects`;
    try {
      const s = await stat(pDir);
      if (s.isDirectory())
        projectDirs.push(pDir);
    } catch {}
  }
  const glob = new Bun.Glob("**/*.jsonl");
  const allFiles = [];
  for (const pDir of projectDirs) {
    for await (const match of glob.scan(pDir)) {
      const filename = match.split("/").pop() ?? "";
      if (filename.startsWith("agent-"))
        continue;
      allFiles.push(`${pDir}/${match}`);
    }
  }
  const now = Math.floor(Date.now() / 1000);
  const all = [];
  for (const file of allFiles) {
    let fileStat;
    try {
      fileStat = await stat(file);
    } catch {
      continue;
    }
    const size = fileStat.size;
    if (size === 0)
      continue;
    const mtime = Math.floor(fileStat.mtimeMs / 1000);
    const text = await Bun.file(file).text();
    const lines = text.split(`
`);
    let sessionId = "?";
    let cwd = "?";
    for (const line of lines) {
      if (line.includes('"cwd"')) {
        const sidMatch = line.match(/"sessionId"\s*:\s*"([^"]+)"/);
        if (sidMatch)
          sessionId = sidMatch[1];
        const cwdMatch = line.match(/"cwd"\s*:\s*"((?:[^"\\]|\\.)*)"/);
        if (cwdMatch)
          cwd = cwdMatch[1];
        break;
      }
    }
    if (cwd === "?" && sessionId === "?") {
      continue;
    }
    all.push({ file, mtime, size, sessionId, cwd });
  }
  let filtered = all;
  if (mmin) {
    filtered = all.filter((e) => {
      const age = now - e.mtime;
      if (mmin.startsWith("+")) {
        const n = parseInt(mmin.slice(1), 10);
        return age > n * 60;
      } else {
        const n = parseInt(mmin.replace(/^-/, ""), 10);
        return age <= n * 60;
      }
    });
  }
  if (keyword) {
    const matched = [];
    for (const e of filtered) {
      const text = await Bun.file(e.file).text();
      const lines = text.split(`
`);
      for (const line of lines) {
        const idx = line.indexOf(keyword);
        if (idx !== -1) {
          const preStart = Math.max(0, idx - 20);
          let pre = line.slice(preStart, idx);
          pre = pre.replace(/.*\n/s, "");
          let post = line.slice(idx + keyword.length, idx + keyword.length + 20);
          post = post.replace(/\n.*/s, "");
          const ctx = `${pre}${keyword}${post}`.replace(/[\r\n]/g, " ");
          matched.push({ ...e, context: ctx });
          break;
        }
      }
    }
    filtered = matched;
  }
  filtered.sort((a, b) => a.mtime - b.mtime);
  return filtered;
}

// src/lib.ts
function lastSegments(path, n = 2) {
  const segments = path.split("/").filter((s) => s !== "");
  if (segments.length <= n)
    return path;
  return segments.slice(-n).join("/");
}

// src/sessions/format.ts
function formatHumanSize(bytes) {
  let v;
  let u;
  if (bytes >= 1e9) {
    v = bytes / 1e9;
    u = "G";
  } else if (bytes >= 1e6) {
    v = bytes / 1e6;
    u = "M";
  } else {
    v = bytes / 1000;
    u = "K";
  }
  if (v >= 100) {
    return `${Math.floor(v).toString().padStart(3)}${u}`;
  } else if (v >= 10) {
    return `${Math.floor(v).toString().padStart(3)}${u}`;
  } else {
    return `${v.toFixed(1)}${u}`;
  }
}
function formatAgo(seconds) {
  let v;
  let u;
  if (seconds < 60) {
    v = seconds;
    u = "s";
  } else if (seconds < 3600) {
    v = Math.floor(seconds / 60);
    u = "m";
  } else if (seconds < 86400) {
    v = Math.floor(seconds / 3600);
    u = "h";
  } else {
    v = Math.floor(seconds / 86400);
    u = "d";
  }
  return `${v.toString().padStart(2)}${u}`;
}
function formatSessionLine(session, opts) {
  const age = opts.now - session.mtime;
  const agoStr = formatAgo(age);
  const sizeStr = formatHumanSize(session.size);
  const sid = opts.full ? session.sessionId : session.sessionId.slice(0, 8);
  const dir = opts.full ? session.cwd : lastSegments(session.cwd, 2);
  const ctx = session.context ? `	${session.context}` : "";
  return `${agoStr}	${sizeStr}	${sid}	${dir}${ctx}`;
}
function formatSessionsOutput(allSessions, filtered, opts) {
  const now = opts.now ?? Math.floor(Date.now() / 1000);
  const lines = [];
  if (allSessions.length > 0) {
    const oldest = allSessions[0];
    const newest = allSessions[allSessions.length - 1];
    const oldestAgo = formatAgo(now - oldest.mtime);
    const newestAgo = formatAgo(now - newest.mtime);
    lines.push(`# ${allSessions.length} sessions (${oldestAgo} .. ${newestAgo})`);
  }
  const output = opts.tail > 0 && filtered.length > opts.tail ? filtered.slice(-opts.tail) : filtered;
  for (const session of output) {
    lines.push(formatSessionLine(session, { full: opts.full, now }));
  }
  return lines.join(`
`);
}

// src/sessions/index.ts
function printUsage(exitCode = 0) {
  const prog = process.env._PROG || "sessions";
  console.log(`Usage: ${prog} [-g kw] [-mmin N] [-n N] [--full]
  -g: search keyword, output session ID only
  -mmin N: +N=older than N min, -N/N=newer than N min (default: 1440 = 1day)
  -n N: show last N sessions (default: 10)
  --full: show full session ID and cwd`);
  process.exit(exitCode);
}
function parseArgs(argv) {
  let keyword = "";
  let mmin = "1440";
  let tail = 10;
  let full = false;
  let i = 0;
  while (i < argv.length) {
    switch (argv[i]) {
      case "--help":
      case "-h":
        printUsage(0);
        break;
      case "-g":
        keyword = argv[++i] ?? "";
        break;
      case "-mmin":
        mmin = argv[++i] ?? "1440";
        break;
      case "-n":
        tail = parseInt(argv[++i] ?? "10", 10);
        break;
      case "--full":
        full = true;
        break;
      default:
        break;
    }
    i++;
  }
  return { keyword, mmin, tail, full };
}
async function main() {
  const args = parseArgs(process.argv.slice(2));
  const configDir = process.env.CLAUDE_CONFIG_DIR;
  const defaultDir = `${process.env.HOME}/.claude`;
  const configDirs = [];
  if (configDir) {
    configDirs.push(configDir);
    if (configDir !== defaultDir) {
      configDirs.push(defaultDir);
    }
  } else {
    configDirs.push(defaultDir);
  }
  const allSessions = await searchSessions({ configDirs });
  allSessions.sort((a, b) => a.mtime - b.mtime);
  const filtered = await searchSessions({
    configDirs,
    mmin: args.mmin,
    keyword: args.keyword || undefined
  });
  const output = formatSessionsOutput(allSessions, filtered, {
    full: args.full,
    tail: args.tail
  });
  if (output) {
    await Bun.write(Bun.stdout, output + `
`);
  }
}
main().catch((err) => {
  console.error(err.message);
  process.exit(1);
});
